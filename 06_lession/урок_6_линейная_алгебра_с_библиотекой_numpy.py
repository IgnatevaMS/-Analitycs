# -*- coding: utf-8 -*-
"""Урок 6. Линейная алгебра с библиотекой Numpy.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CK9ikSniNMKDn-WLAQPxtnddddSCK9gd

# 1. Подготовка данных
"""

# Источник и описание полей датасета: http://archive.ics.uci.edu/ml/datasets/online+retail#

# Импортируем нужные библиотеки
import pandas as pd
import numpy as np

# Загружаем и читаем датасет
# df = pd.read_excel('http://archive.ics.uci.edu/ml/machine-learning-databases/00352/Online%20Retail.xlsx')
df = pd.read_excel('http://archive.ics.uci.edu/ml/machine-learning-databases/00352/Online%20Retail.xlsx')
df.head()

# Смотрим размеры датасета
df.shape

# Чистим датасет: удаляем записи с нулевыми покупками
df = df.loc[df['Quantity'] > 0]

# Чистим датасет: удаляем записи с пропусками в customer_id
df = df.dropna(subset=['CustomerID'])

# Агрегируем данные в сводную таблицу "покупатель - товар"
customer_item_matrix = df.pivot_table(index='CustomerID', columns='StockCode', values='Quantity', aggfunc='sum')
customer_item_matrix.head()

# Смотрим на размеры таблицы
customer_item_matrix.shape

# Сравниваем кол-во строк с кол-вом уникальных покупателей в исходном датафрейме
df['CustomerID'].nunique()

# Сравниваем кол-во столбцов с кол-вом уникальных товаров в исходном датафрейме
df['StockCode'].nunique()

# Заменяем кол-во покупок на событие: 1- факт покупки, 0 - отсутствие покупки
customer_item_matrix = customer_item_matrix.applymap(lambda x: 1 if x > 0 else 0)
customer_item_matrix.head()

"""#2. Коллаборативная фильтрация (Collaborative Filtering)"""

# Преобразуем исходную матрицу "покупатель - товар" в массив numpy
m = customer_item_matrix.values
m

# Импортируем библиотеку для создания разреженной матрицы
from scipy.sparse import csr_matrix

# Задаем функцию расчета косинуса между векторами-строками покупателей
def cos_sim(array):
  # преобразуем 
  csr_array = csr_matrix(array)
  numerator = np.dot(csr_array,csr_array.T).toarray()
  denomenator = np.linalg.norm(array, axis = 1, keepdims = True)*np.linalg.norm(array.T, axis = 0, keepdims = True)
  return numerator / denomenator

# Вычисляем косинусную меру сходства между векторами-строками покупателей 
user_user_sim_matrix = cos_sim(m)
user_user_sim_matrix

# Добавляем название столбцов и индексов в матрицу мер близости между векторами-строками покупателей 
user_user_sim_matrix = pd.DataFrame(user_user_sim_matrix)

user_user_sim_matrix.columns = customer_item_matrix.index

user_user_sim_matrix['CustomerID'] = customer_item_matrix.index
user_user_sim_matrix = user_user_sim_matrix.set_index('CustomerID')

user_user_sim_matrix.head()

"""# 3. Рекомендации на основе коллабортивной фильтрации"""

# На примере эталонного покупателя находим тех покупателей, которые близки к нему по косинусной мере
user_user_sim_matrix.loc[12350.0].sort_values(ascending=False)

# Определяем перечень уникальных покупок нашего эталонного покупателя
A = customer_item_matrix.loc[12350.0]
items_bought_by_A = A[A>0].index.tolist()
items_bought_by_A

# Определяем перечень уникальных покупок покупателя наиболее близкого к нашему
B = customer_item_matrix.loc[17935.0]
items_bought_by_B = B[B>0].index.tolist()
items_bought_by_B

# Отбираем те покупки, которые есть у близкого к нашему покупателю, но нет у нашего покупателя
items_to_recommend_to_A = set(items_bought_by_B) - set(items_bought_by_A)
items_to_recommend_to_A

# Выводим перечень товаров эталонного покупателя
df.loc[df['StockCode'].isin(items_bought_by_A), ['StockCode', 'Description']].drop_duplicates().set_index('StockCode')

# Выводим перечень товаров, рекомендованных для нашего эталонного покупателя
df.loc[df['StockCode'].isin(items_to_recommend_to_A), ['StockCode', 'Description']].drop_duplicates().set_index('StockCode')

