# -*- coding: utf-8 -*-
"""Урок 5. Python. Статистика в работе аналитика с библиотекой Scipy.ipynb"

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Twmtm02zG7dU5kZKpo4HvrGKZCPTc_gP

# Задача анализа A/B тестов

1) A/B-тест с категориальной метерикой (метрикой пропорции)
"""

# импортируем нужные библиотеки
import pandas as pd

# создаем датафрейм с результатами A/B-теста
df = pd.DataFrame({'impressions': [5127, 5127],
                   'clicks': [1145,1250]},
                  index=['var_A', 'var_B'])
df.head()

# создаем таблицу сопряженности на основе результатов A/B-теста
df['no_clicks'] = df['impressions'] - df['clicks']
df = df.drop(['impressions'], axis = 1)
df.head()

# определяем значимость аб-теста
import scipy.stats as stats
result = stats.chi2_contingency(df, correction = False)
chisq, pvalue = result[:2]
print('chisq = {}, pvalue = {}'.format(chisq, pvalue))

"""Вывод: поскольку значимость A/B теста 0.014 менее допустимого уровня значимости 0,05, то нулевую гипотезу о равенстве конверсий в группах можно отклонить, т.е. группа B -действительно генерирует статистически больше кликов, чем группа A

2) A/B - тест с числовой метрикой
"""

# создаем датафрейм на основе словаря
df = pd.DataFrame({'Day': [1,2,3,4,5,6,7,8,9,10],
                   'Conversion_A': [0.15,0.12,0.18,0.19,0.17,0.13,0.14,0.23,0.11,0.15],
                   'Conversion_B': [0.19,0.20,0.18,0.22,0.19,0.17,0.18,0.20,0.17,0.22]})
df.head()

# визуализируем наличие различий в группах аб-теста
import matplotlib.pyplot as plt
from matplotlib.ticker import PercentFormatter
import seaborn as sns
plt.figure(figsize=(5, 7))
ax = sns.boxplot(data=df[['Conversion_A','Conversion_B']], palette="Set2")
ax.yaxis.set_major_formatter(PercentFormatter(xmax=1))

# считаем значимость различий по аб-тесту
import scipy.stats as stats
t_stat, p_val= stats.ttest_ind(df['Conversion_B'],df['Conversion_A'])
t_stat , p_val

"""Вывод: поскольку значимость A/B теста 0.013 менее допустимого уровня значимости 0,05, то нулевую гипотезу о равенстве конверсий в группах можно отклонить, т.е. группа B -действительно генерирует статистически больше покупателей, чем группа A

# Задача оптимизации
"""

# Импортируем нужные бибилиотеки
import numpy as np

# Задаем целевую функцию:
# Компанией производится три вида продукции:
# x0 — продающие лэндинги, от 10 т.р.
# x1 — корпоративные сайты, от 20 т.р.
# x2 — интернет магазины, от 30 т.р.

def value(x):
    return - 10*x[0] - 20*x[1] - 30*x[2]

# Задаем систему ограничений:
# Дружный рабочий коллектив включает в себя четырех джунов, двух мидлов и одного сеньора. 
# Фонд их рабочего времени на месяц:
# джуны: 4 * 150 = 600 чел * час,
# мидлы: 2 * 150 = 300 чел * час,
# сеньор: 150 чел * час.

#Пусть на разработку и деплой одного сайта типа (x0, x1, x2) первый попавшийся джуниор 
# должен потратить (10, 20, 30) часов, мидл — (7, 15, 20), сеньор — (5, 10, 15) часов рабочего времен.

neq_cons = {'type': 'ineq',
             'fun': lambda x: np.array ([600 - 10 * x [0] - 20 * x [1] - 30 * x[2],
                                         300 - 7  * x [0] - 15 * x [1] - 20 * x[2],
                                         150 - 5  * x [0] - 10 * x [1] - 15 * x[2]])}

# Формальное ограничение — выпуск продукции должен быть только положительным:
from scipy.optimize import Bounds
bnds = Bounds([0, 0, 0], [np.inf, np.inf, np.inf])

# Максимизируем функцию ежемесячной прибыли
from scipy.optimize import minimize
x0 = np.array([10, 10, 10])
res = minimize(value, x0, method='SLSQP', constraints=neq_cons, bounds=bnds)
print(res.x)

# Нестрого округлим до целых и посчитаем месячную загрузку гребцов при оптимальном раскладе продукции x = (8, 6, 3) :
print('джуны:', 8 * 10 + 6 * 20 + 3 * 30, 'чел.*час')
print('мидлы:', 8 * 7 + 6 * 15 + 3 * 20, 'чел.*час')
print('сеньор:', 8 * 5 + 6 * 10 + 3 * 15, 'чел.*час')
print('максимизированная прибыль составит:', -1*value([8, 6, 3]),'тыс.руб./месяц')

"""Вывод: чтобы студия получала максимульную выручку, оптимально делать в месяц по 8 лэндингов, 6 средних сайтов и 3 магазина. Сеньор при этом должен работать 100% от фонда рабочего времени, загрузка мидлов составит примерно 2/3, джунов меньше половины.

# Задача аппроксимации
"""

# импортируем нужные бибилиотеки
import pandas as pd
import numpy as np

# создаем датафрейм с помощью словаря - номер дня и кол-во удержанных пользователей сайта 
df = pd.DataFrame({'day': [0,1,7,14,21,30],
                   'retained': [100,55,38,26,21,14]})
df.head(6)

# определяем тип возможной кривой по диаграмме рассеяния
import matplotlib.pyplot as plt
from matplotlib.pyplot import figure
plt.figure(num=None, figsize=(8, 6), dpi=80, facecolor='w', edgecolor='k')
plt.scatter(df['day'], df['retained'], label="Original Data" )

# задаем аппроксимирующую логарифмияескую функцию
def log_func( x, a, b, c ):
    return -a * np.log2( b + x ) + c

# задаем аппроксимирующую экспоненциальную функцию
def exp_func( x, a, b, c ):
    return a * np.exp( -b * x ) + c

# подбираем оптимальные параметры логарифмияеской функции
from scipy.optimize import curve_fit
log_popt, log_pcov = curve_fit(log_func, df['day'], df['retained'])

# подбираем оптимальные параметры экспоненциальной функции
exp_popt, exp_pcov = curve_fit(exp_func, df['day'], df['retained'])

# задаем точку прогноза - сколько удержанных пользователей сайта останется на 90й день
projection_endpoint = 90

# задаем значения функции x с помощью метода np.arange и параметры подобранной кривой
log_y_projected = log_func( np.arange( projection_endpoint ), *log_popt )
exp_y_projected = exp_func( np.arange( projection_endpoint ), *exp_popt )

# смотрим график исходных данных и полученных кривых
import matplotlib.pyplot as plt
from matplotlib.pyplot import figure
plt.figure(num=None, figsize=(8, 6), dpi=80, facecolor='w', edgecolor='k')
plt.scatter(df['day'], df['retained'], label="Original Data" )
plt.plot( log_y_projected, label="Log Function Projections" )
plt.plot( exp_y_projected, label="Exp Function Projections" )
plt.legend()
plt.show()

# делаем прогноз удержанных пользователей сайта на 90й день
print('Прогноз кол-ва пользователей через 90 дней по log модели', round(log_y_projected[89],0))
print('Прогноз кол-ва пользователей через 90 дней по exp модели', round(exp_y_projected[89],0))

# отбираем среди прогнозов значения за 0,1,7,14,21 и 30 дни
y_log_pred = [log_y_projected[ i ] for i in list(df['day'])]
y_log_pred

# отбираем среди прогнозов значения за 0,1,7,14,21 и 30 дни
y_exp_pred = [exp_y_projected[ i ] for i in list(df['day'])]
y_exp_pred

"""Вывод: логарифмическая функция аппроксимирует исследуемую зависимость с меньшей среднеквадратической ошибкой, поэтому целесообразнее использовать для прогноза только данную функцию."""